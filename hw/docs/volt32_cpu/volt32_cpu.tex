\documentclass{article}

\usepackage{pbox}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{setspace}
\usepackage[nottoc]{tocbibind}
\usepackage[font=large]{caption}
\usepackage{framed}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{fontspec}
\usepackage[backend=biber,sorting=none]{biblatex}
%%\usepackage[
%%	backend=biber,
%%	style=ieee,
%%	sorting=none
%%]{biblatex}
%\addbibresource{project_refs.bib}

%% Hide section, subsection, and subsubsection numbering
%\renewcommand{\thesection}{}
%\renewcommand{\thesubsection}{}
%\renewcommand{\thesubsubsection}{}

% Alternative form of doing section stuff
\renewcommand{\thesection}{}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\csname #1ignore\expandafter\endcsname\csname the#1\endcsname\quad}
\let\sectionignore\@gobbletwo
\let\latex@numberline\numberline
\def\numberline#1{\if\relax#1\relax\else\latex@numberline{#1}\fi}
\makeatother

\makeatletter
\renewcommand\tableofcontents{%
    \@starttoc{toc}%
}
\makeatother

\newcommand{\respacing}{\doublespacing \singlespacing}
\newcommand{\code}[2][1]{\noindent \texttt{\tab[#1] #2} \\}
\newcommand{\skipline}[0]{\texttt{}\\}
\newcommand{\tnl}[0]{\tabularnewline}

\begin{document}
%--------
	\font\titlefont={Times New Roman} at 20pt
	\title{{\titlefont Volt32 CPU}}

	\font\bottomtextfont={Times New Roman} at 12pt
	\date{{\bottomtextfont} \today}
	\author{{\bottomtextfont Andrew Clark}}

	\setmainfont{Times New Roman}
	\setmonofont{Courier New}

	\maketitle
	\pagenumbering{gobble}

	\newpage
	\pagenumbering{arabic}
	%\tableofcontents
	%\newpage

	%\doublespacing

%\section{Abstract}
	%\setcounter{section}{-1}

\section{Table of Contents}
	\tableofcontents
	\newpage

\section{Registers, Main Widths, etc.}
	\begin{itemize}
	%--------
	\item The main width of the processor is 32-bit, and addresses are
	32-bit.  Some 64-bit operations exist.

	\item The machine is an implementation of Line Associative Registers
	(LARs).  Both instruction LARs (ILARs) and data LARs (DLARs) are
	included in the design.  There are a grand total of 128 ILARs and 128
	DLARs, but they are split between the LARs owned by the supervisor
	mode and the LARs owned by the user mode.  There are 64 supervisor mode
	ILARs, 64 supervisor mode DLARs, 64 user mode ILARs, and 64 user mode
	DLARs.

	\item The machine boots in supervisor mode.  The processor jumps to
	address \texttt{0x0} when it enters supervisor mode, which includes
	when the machine boots.

	\item ILARs
		\begin{itemize}
		%--------
		\item In user mode, ILARs 0 to 63 are referred to as \texttt{i0},
		\texttt{i1}, \texttt{i2}, ..., \texttt{i61}, \texttt{i62},
		\texttt{ipc}.

		\item In supervisor mode, ILARs 64 to 127 are referred to as
		\texttt{i0}, \texttt{i1}, \texttt{i2}, ..., \texttt{i61},
		\texttt{i62}, \texttt{ipc}.

		\item The two ILARs called "\texttt{i0}" have all their
		fields set to zero, and when written to, the contents of the ILAR
		does not change.

		\item The two ILARs called "\texttt{ipc}" are the program
		counters for the two operating modes of the processor.

		\item An ILAR's data field is 128 bytes long.  It is composed of
		32-bit instructions aligned to 32 bits.

		\item An ILAR's scalar offset field is 5-bit due to instructions
		being 32-bit and the data field being 128 bytes long.

		\item The base address field of an ILAR is (32 - 7 = 25)-bit.

		\item An ILAR's tag field is 6-bit.
		%--------
		\end{itemize}

	\item DLARs
		\begin{itemize}
		%--------
		\item In user mode, DLARs 0 to 63 are referred to as \texttt{d0},
		\texttt{d1}, \texttt{d2}, ..., \texttt{d59}, \texttt{d60},
		\texttt{dcp}, \texttt{dfp}, \texttt{dsp}.

		\item In supervisor mode, DLARs 64 to 127 are referred to as
		\texttt{d0}, \texttt{d1}, \texttt{d2}, ..., \texttt{d59},
		\texttt{d60}, \texttt{dcp}, \texttt{dfp}, \texttt{dsp}.

		\item The two DLARs called "\texttt{d0}" have all their
		fields set to zero, and when written to, the contents of the DLAR
		does not change.

		\item A DLAR's data field is 128 bytes long.  It is composed of the
		scalar data elements of the 128 byte vectors, where the type of the
		scalar data elements is determined by the type tag field of the
		DLAR.

		\item A DLAR's scalar offset field is 7-bit due to the data field
		being 128 bytes long.

		\item The base address field of a DLAR is (32 - 7 = 25)-bit.

		\item DLARs can take on the following types (3-bit enum):
			\begin{itemize}
			%--------
			\item 8-bit, unsigned (\texttt{u8})
			\item 8-bit, signed (\texttt{i8})
			\item 16-bit, unsigned (\texttt{u16})
			\item 16-bit, signed (\texttt{i16})
			\item 32-bit, unsigned (\texttt{u32})
			\item 32-bit, signed (\texttt{i32})
			\item 64-bit, unsigned (\texttt{u64}); only usable for some
			operations
			\item 64-bit, signed (\texttt{i64}); only usable for some
			operations
			%--------
			\end{itemize}

		\item A DLAR's tag field is 6-bit.
		%--------
		\end{itemize}

	\item The \texttt{ie} register
		\begin{itemize}
		%--------
		\item This register is 1-bit.

		\item This register is a flag indicating whether or not an
		interrupt can be serviced.  It can be written to with the
		\texttt{cpy} instruction (with \texttt{ie} as the destination
		operand), and it can be read from with the \texttt{cpy} instruction
		(with \texttt{ie} as the source operand).

		\item The \texttt{reti} instruction sets \texttt{ie} to
		\texttt{0b1} and returns to user mode from supervisor mode.
		%--------
		\end{itemize}

	\item The \texttt{xct} register
		\begin{itemize}
		%--------
		\item This register is 32-bit.

		\item This register gets set to one of the following values upon
		the machine entering supervisor mode.  It can be written to using
		the \texttt{cpy} instruction (with \texttt{xct} as the destination
		operand), and it can be read from using the \texttt{cpy}
		instruction (with \texttt{xct} as the source operand).
		%--------
		\end{itemize}
	%--------
	\end{itemize}
	\newpage

\section{Exceptions}
	Some instructions may cause an exception to occur, putting the
	processor in supervisor mode.

	The following exceptions may occur during normal execution of a
	program.

	\begin{itemize}
	%--------
	\item Taking an interrupt, which also sets \texttt{ie} to \texttt{0b0}.
	\item Division by zero.
	\item Undefined instruction.
	\item Instructions where 64-bit ops are not defined.
	\item \texttt{swi}.
		\begin{itemize}
		%--------
		\item Note that this instruction always causes an exception to
		occur.
		%--------
		\end{itemize}
	\item \texttt{reti} in user mode.
	\item \texttt{cpy} that reads from/writes to \texttt{ie} when in user
	mode.
	\item \texttt{cpy} that reads from/writes to \texttt{xct} when in user
	mode.
	\item Instructions that read from/write to supervisor mode
	ILARs or DLARs when in user mode.
	%--------
	\end{itemize}
	\newpage

\section{Instructions (CPU's perspective)}
	\subsection{Group 0 Instructions}
		\begin{itemize}
		%--------
		\item Encoding: \texttt{0000 aaaa aabb bbbb  cccc ccdd dddv oooo}
			\begin{itemize}
			%--------
			\item \texttt{a}:  DLAR a
			\item \texttt{b}:  DLAR b
			\item \texttt{c}:  DLAR c
			\item \texttt{d}:  DLAR d (\texttt{d32} to \texttt{d63})
			\item \texttt{v}:
				\begin{itemize}
				%--------
				\item when \texttt{0b0}:  scalar operation
				\item when \texttt{0b1}:  vector operation
				%--------
				\end{itemize}
			\item \texttt{o}:  Opcode
			%--------
			\end{itemize}
		\item Instruction List:
			\begin{enumerate}
			%--------
			\item \texttt{add dA, dB, dC}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dA}
				is of the following types:  \texttt{u64}, \texttt{i64}.
				%--------
				\end{itemize}
			\item \texttt{sub dA, dB, dC}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dA}
				is of the following types:  \texttt{u64}, \texttt{i64}.
				%--------
				\end{itemize}
			\item \texttt{slt dA, dB, dC}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dA}
				is of the following types:  \texttt{u64}, \texttt{i64}.
				%--------
				\end{itemize}
			\item \texttt{mul dA, dB, dC}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dB}
				or \texttt{dC} is of the following types:  \texttt{u64},
				\texttt{i64}.
				%--------
				\end{itemize}

			\item \texttt{div dA, dB, dC, dD}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dB},
				\texttt{dC}, or \texttt{dD} is of the following types:
				\texttt{u64}, \texttt{i64}.

				\item This instruction writes the quotient into
				\texttt{dA}, and the remainder into \texttt{dD}.
				%--------
				\end{itemize}
			\item \texttt{and dA, dB, dC}
			\item \texttt{or dA, dB, dC}
			\item \texttt{xor dA, dB, dC}

			\item \texttt{shl dA, dB, dC}
				\begin{itemize}
				%--------
				\item Logical shift left.

				\item This instruction causes an exception if \texttt{dA},
				\texttt{dB}, or \texttt{dC} is of the following types:
				\texttt{u64}, \texttt{i64}.

				\item This instruction casts a temporary copy of
				\texttt{dC} to the unsigned type that is the same size as
				\texttt{dA}'s type and uses that instead of \texttt{dC}.
				%--------
				\end{itemize}
			\item \texttt{shr dA, dB, dC}
				\begin{itemize}
				%--------
				\item Logical shift right if \texttt{dA} is unsigned, or
				arithmetic shift right if \texttt{dA} is signed.

				\item This instruction causes an exception if \texttt{dA},
				\texttt{dB}, or \texttt{dC} is of the following types:
				\texttt{u64}, \texttt{i64}.

				\item This instruction casts a temporary copy of
				\texttt{dC} to the unsigned type that is the same size as
				\texttt{dA}'s type and uses that instead of \texttt{dC}.
				%--------
				\end{itemize}
			\item \texttt{rol dA, dB, dC}
				\begin{itemize}
				%--------
				\item Rotate left.

				\item This instruction causes an exception if \texttt{dA},
				\texttt{dB}, or \texttt{dC} is of the following types:
				\texttt{u64}, \texttt{i64}.

				\item This instruction casts a temporary copy of
				\texttt{dC} to the unsigned type that is the same size as
				\texttt{dA}'s type and uses that instead of \texttt{dC}.
				%--------
				\end{itemize}
			\item \texttt{ror dA, dB, dC}
				\begin{itemize}
				%--------
				\item Rotate right.

				\item This instruction causes an exception if \texttt{dA},
				\texttt{dB}, or \texttt{dC} is of the following types:
				\texttt{u64}, \texttt{i64}.

				\item This instruction casts a temporary copy of
				\texttt{dC} to the unsigned type that is the same size as
				\texttt{dA}'s type and uses that instead of \texttt{dC}.
				%--------
				\end{itemize}

			\item \texttt{add dA, dB.addr, dC}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dA}
				or \texttt{dC} is of the following types: \texttt{u64},
				\texttt{i64}.

				\item For \texttt{add.v dA, dB.addr, dC}, this instruction
				duplicates \texttt{cast(dA.type, dB.addr)} (a scalar) into
				a temporary (128 bytes long) vector of element type
				\texttt{dA.type}.
				%--------
				\end{itemize}
			\item \texttt{shl dA, dB.addr, dC}
				\begin{itemize}
				%--------
				\item This instruction causes an exception if \texttt{dA}
				or \texttt{dC} is of the following types: \texttt{u64},
				\texttt{i64}.

				\item For \texttt{shl.v dA, dB.addr, dC}, this instruction
				duplicates \texttt{cast(dA.type, dB.addr)} (a scalar) into
				a temporary (128 bytes long) vector of element type
				\texttt{dA.type}.

				\item This instruction casts a temporary copy of
				\texttt{dC} to the unsigned type that is the same size as
				\texttt{dA}'s type and uses that instead of \texttt{dC}.
				%--------
				\end{itemize}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			%--------
			\end{enumerate}
		%--------
		\end{itemize}
		\newpage

	\subsection{Group 1 Instructions}
		\begin{itemize}
		%--------
		\item Encoding: \texttt{0001 aaaa aabb bbbb  cccc ccii iiii iooo}
			\begin{itemize}
			%--------
			\item \texttt{a}:  DLAR a
			\item \texttt{b}:  DLAR b
			\item \texttt{c}:  DLAR c
			\item \texttt{i}:  \texttt{simm7} (sign-extended 7-bit
			immediate)
			\item \texttt{o}:  Opcode
			%--------
			\end{itemize}

		\item For these instructions, the \texttt{dB} register's scalar
		data field (temporarily casted to the \texttt{u32} type) and the
		\texttt{dC} register's address field are used. 

		\item Instruction List:
			\begin{enumerate}
			%--------
			\item \texttt{ldu8 dA, dB, dC, simm7}
			\item \texttt{ldi8 dA, dB, dC, simm7}
			\item \texttt{ldu16 dA, dB, dC, simm7}
			\item \texttt{ldi16 dA, dB, dC, simm7}
			\item \texttt{ldu32 dA, dB, dC, simm7}
			\item \texttt{ldi32 dA, dB, dC, simm7}
			\item \texttt{ldu64 dA, dB, dC, simm7}
			\item \texttt{ldi64 dA, dB, dC, simm7}
			%--------
			\end{enumerate}
		%--------
		\end{itemize}
		\newpage

	\subsection{Group 2 Instructions}
		\begin{itemize}
		%--------
		\item Encoding: \texttt{0010 aaaa aabb bbbb  cccc ccii iiii iooo}
			\begin{itemize}
			%--------
			\item \texttt{a}:  DLAR a
			\item \texttt{b}:  DLAR b
			\item \texttt{c}:  DLAR c
			\item \texttt{i}:  \texttt{simm7} (sign-extended 7-bit
			immediate)
			\item \texttt{o}:  Opcode
			%--------
			\end{itemize}

		\item For these instructions, the \texttt{dB} register's scalar
		data field (temporarily casted to the \texttt{u32} type) and the
		\texttt{dC} register's address field are used. 

		\item Instruction List:
			\begin{enumerate}
			%--------
			\item \texttt{stu8 dA, dB, dC, simm7}
			\item \texttt{sti8 dA, dB, dC, simm7}
			\item \texttt{stu16 dA, dB, dC, simm7}
			\item \texttt{sti16 dA, dB, dC, simm7}
			\item \texttt{stu32 dA, dB, dC, simm7}
			\item \texttt{sti32 dA, dB, dC, simm7}
			\item \texttt{stu64 dA, dB, dC, simm7}
			\item \texttt{sti64 dA, dB, dC, simm7}
			%--------
			\end{enumerate}
		%--------
		\end{itemize}
		\newpage

	\subsection{Group 3 Instructions}
		\begin{itemize}
		%--------
		\item Encoding: \texttt{0011 aaaa aabb bbbb  0000 0000 0000 0ooo}
			\begin{itemize}
			%--------
			\item \texttt{a}:  DLAR a
			\item \texttt{b}:  DLAR b
			\item \texttt{o}:  Opcode
			%--------
			\end{itemize}

		\item For these instructions, the \texttt{dB} register's scalar
		data field is used.

		\item Instruction List:
			\begin{enumerate}
			%--------
			\item \texttt{dpu8 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{u8} type.  The
				casted scalar data is then stored into every \texttt{u8}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{u8}.
				%--------
				\end{itemize}
			\item \texttt{dpi8 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{i8} type.  The
				casted scalar data is then stored into every \texttt{i8}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{i8}.
				%--------
				\end{itemize}
			\item \texttt{dpu16 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{u16} type.  The
				casted scalar data is then stored into every \texttt{u16}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{u16}.
				%--------
				\end{itemize}
			\item \texttt{dpi16 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{i16} type.  The
				casted scalar data is then stored into every \texttt{i16}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{i16}.
				%--------
				\end{itemize}

			\item \texttt{dpu32 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{u32} type.  The
				casted scalar data is then stored into every \texttt{u32}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{u32}.
				%--------
				\end{itemize}
			\item \texttt{dpi32 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{i32} type.  The
				casted scalar data is then stored into every \texttt{i32}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{i32}.
				%--------
				\end{itemize}
			\item \texttt{dpu64 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{u64} type.  The
				casted scalar data is then stored into every \texttt{u64}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{u64}.
				%--------
				\end{itemize}
			\item \texttt{dpi64 dA, dB}
				\begin{itemize}
				%--------
				\item This instruction casts (a temporary copy of) the
				scalar data of \texttt{dB} to the \texttt{i64} type.  The
				casted scalar data is then stored into every \texttt{i64}
				vector element of \texttt{dA}.  The type of \texttt{dA} is
				then changed to \texttt{i64}.
				%--------
				\end{itemize}
			%--------
			\end{enumerate}
		%--------
		\end{itemize}
		\newpage

	\subsection{Group 4 Instructions}
		\begin{itemize}
		%--------
		\item Encoding:  \texttt{0100 aaaa aabb bbbb  cccc ccii iiii iiii}
			\begin{itemize}
			%--------
			\item \texttt{a}:  ILAR a
			\item \texttt{b}:  ILAR b
			\item \texttt{c}:  DLAR c
			\item \texttt{i}:  \texttt{simm10} (sign-extended 10-bit
			immediate)
			%--------
			\end{itemize}

		\item This instruction uses the address field of \texttt{iB} and
		the scalar data field (temporarily casted to the \texttt{u32} type)
		of the \texttt{dC} register.

		\item Instruction List:
			\begin{enumerate}
			%--------
			\item \texttt{fetch iA, iB, dC, simm10}
			%--------
			\end{enumerate}
		%--------
		\end{itemize}
		\newpage

	\subsection{Group 5 Instructions}
		\begin{itemize}
		%--------
		\item Encoding:  \texttt{0101 aaaa aabb bbbb  iiii ijjj jj0v oooo}
			\begin{itemize}
			%--------
			\item \texttt{a}:  DLAR a
			\item \texttt{b}:  ILAR b
			\item \texttt{i}:  \texttt{iimm5} (zero-extended 5-bit
			immediate i)
			\item \texttt{j}:  \texttt{jimm5} (zero-extended 5-bit
			immediate j)
			\item \texttt{v}:
				\begin{itemize}
				%--------
				\item when \texttt{0b0}:  scalar operation (uses the scalar
				data of \texttt{dA})
				\item when \texttt{0b1}:  vector operation (uses the vector
				data of \texttt{dA})
				%--------
				\end{itemize}
			\item \texttt{o}:  Opcode
			%--------
			\end{itemize}

		\item These instructions use the scalar or vector data field of
		\texttt{dA}.

		\item Instruction List:
			\begin{enumerate}
			%--------
			\item \texttt{sel dA, iB, iimm5, jimm5}
				\begin{itemize}
				%--------
				\item This instruction jumps to \texttt{iB[iimm5 << 2]} if
				the particular data field of \texttt{dA}
				is non-zero, otherwise to the address \texttt{iB[jimm5 <<
				2]}.
				%--------
				\end{itemize}
			\item \texttt{jz dA, iB, iimm5}
				\begin{itemize}
				%--------
				\item This instruction jumps to \texttt{iB[iimm5 << 2]}
				if the particular data field of \texttt{dA} is zero.
				%--------
				\end{itemize}
			\item \texttt{jnz dA, iB, iimm5}
				\begin{itemize}
				%--------
				\item This instruction jumps to \texttt{iB[iimm5 << 2]}
				if the particular data field of \texttt{dA} is non-zero.
				%--------
				\end{itemize}
			\item \texttt{reti dA}
				\begin{itemize}
				%--------
				\item This instruction returns from an interrupt if in
				supervisor mode and \texttt{dA} is non-zero, setting
				\texttt{ie}
				%--------
				\end{itemize}

			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}

			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}

			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			\item \textit{Reserved for future expansion.}
			%--------
			\end{enumerate}
		%--------
		\end{itemize}
		\newpage


	%\printbibliography[heading=bibnumbered,title={Bibliography}]

%--------
\end{document}
